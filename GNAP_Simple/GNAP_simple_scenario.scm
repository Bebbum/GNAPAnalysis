(herald "Grant Negotiation and Authorization Protocol"
	(limit 100)
	(comment "This protocol allows a piece of software, the client instance, to request delegated authorization to resource servers and to request direct information"))

(defprotocol single_token_simple basic
	(defrole client
		(vars (c as rs name) (access acess_token value rights response data) (n1 n2 text) (k akey))
		(trace
			; (Section 12.16 p.123) Since TLS protects the entire HTTP message in transit, verification of the TLS client certificate
			; presented with the message provides a sufficient binding between the two.			
			; In this case we assume communcation over encrypted TLS connection with (ltk c as) as the certificate
			; (Section 12.5 p.114) With asymmetric keys, the client needs only to send its public key to  the AS to allow for 
			; verification that the client holds the associated private key, regardless of whether that key was pre-registered
			; or not with the AS.
			(send (enc c access (pubk c) (ltk c as))) ; client requests access at the AS by identifying itself and proving possession of a cryptogrphic key
			(recv (enc (enc n1 (enc (cat acess_token value rights) (invk k)) (pubk c)) (ltk c as))) ; receives and decrypts message using private key whic results in a usable access token
			(send (enc (enc n2 (enc (cat acess_token value rights) (invk k)) (pubk c)) (ltk c rs))) ; The client instance uses the access token to call the RS.
			(recv (enc (enc response (pubk c)) (ltk c rs)))
		)
	)
	(defrole authorization_server
		(vars (c as name) (access acess_token value rights data) (n1 text) (k akey))
		(trace
			(recv (enc c access (pubk c) (ltk c as))) ; AS validates the client's request
			; For access_token REQUIRED value and RECOMMENDED rights are included
			; (Section 12.6 p.115-116) The content of access tokens need to be such that only the generating AS would be able to create them, and the contents cannot be
			; manipulated by an attacker to gain different or additional access rights. One method for accomplishing this is to use a cryptographically random value 
			; for the access token, generated by the AS using a secure randomization function with sufficiently high entropy. Another method for accomplishing this 
			; is to use a structured token that is cryptographically signed. In this case, the payload of the access token declares to the RS what the token is 
			; good for, but the signature applied by the AS during token generation covers this payload.
			; (Section 12.8 p.117) Key proofing mechanisms used with access tokens need to use replay protection mechanisms covered
			; under the signature such as a per-message nonce, a reasonably short time validity window, or other uniqueness 
			; constraints.
			(send (enc (enc n1 (enc (cat acess_token value rights) (invk k)) (pubk c)) (ltk c as))) ; AS signs token and binds it to client's public key
		)
	)
	(defrole resource_server
		(vars (c rs name) (acess_token value rights response data) (n2 text) (k akey))
		(trace
			(recv (enc (enc n2 (enc (cat acess_token value rights) (invk k)) (pubk c)) (ltk c rs))) ; RS decrypts and validates the client's token
			(send (enc (enc response (pubk c)) (ltk c rs)))
		)
	)
)

(defskeleton single_token_simple
  (vars (c as rs name) (n2 text) (k akey))
  (defstrand client 4 (c c) (as as) (rs rs) (n2 n2) (k k))
  (non-orig (ltk c as) (ltk c rs) k)
  (uniq-orig n2)
)