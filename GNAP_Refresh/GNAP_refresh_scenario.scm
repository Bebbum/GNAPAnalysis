(herald "Grant Negotiation and Authorization Protocol"
	(limit 20000)
	(comment "This protocol allows a piece of software, the client instance, to request delegated authorization to resource servers and to request direct information"))

(defprotocol token_refresh basic
	(defrole client
		(vars (c as rs name) (access management_uri management_uri_new response response_error response_new data) (n1 n2 n3 n4 text) (token token_new mesg))
		(trace
			; (Section 12.16 p.123) Since TLS protects the entire HTTP message in transit, verification of the TLS client 
			; certificate presented with the message provides a sufficient binding between the two.
			
			; (Section 12.5 p.114) With asymmetric keys, the client needs only to send its public key to  the AS to allow for 
			; verification that the client holds the associated private key, regardless of whether that key was pre-registered
			; or not with the AS.
			(send (enc c n1 (pubk as)))
			(recv (enc as n1 n2 (pubk c)))
			(send (enc n2 (pubk as)))
			(send (enc c access (hash n1 n2)))
			(recv (enc management_uri token (hash n1 n2)))
			(send (enc c n3 (pubk rs)))
			(recv (enc rs n3 n4 (pubk c)))
			(send (enc n4 (pubk rs)))
			(send (enc token (hash n3 n4)))
			(recv (enc response (hash n3 n4)))
			(send (enc token (hash n3 n4)))
			(recv (enc response_error (hash n3 n4)))
			(send (enc token (hash n1 n2)))
			(recv (enc management_uri_new token_new (hash n1 n2)))
			(send (enc token_new (hash n3 n4)))
			(recv (enc response_new (hash n3 n4)))
		)
	)
	(defrole authorization_server
		(vars (c as rs name) (access access_token access_token_new access_type management_uri management_uri_new value data) (n1 n2 text))
		(trace
			; For access_token REQUIRED value and RECOMMENDED access with REQUIRED type are included
			; (Section 12.6 p.115-116) The content of access tokens need to be such that only the generating AS would be able to create them, and the contents cannot be manipulated by an attacker to gain different or additional access rights. 
			; One method for accomplishing this is to use a cryptographically random value for the access token, generated by the 
			; AS using a secure randomization function with sufficiently high entropy. Another method for accomplishing this 
			; is to use a structured token that is cryptographically signed. In this case, the payload of the access token declares
			; to the RS what the token is good for, but the signature applied by the AS during token generation covers this payload.
			
			; (Section 12.8 p.117) Key proofing mechanisms used with access tokens need to use replay protection mechanisms covered
			; under the signature such as a per-message nonce, a reasonably short time validity window, or other uniqueness 
			; constraints.
			
			; The access associated with the access token is described using objects that each contain multiple dimensions of access.
			; Each object contains a REQUIRED type property that determines the type of API that the token is used for.
			
			; (RS RFC Section 2 p.3) The core GNAP protocol makes no assumptions or demands on the format or contents of the access
			; token, and in fact the token format and contents are opaque to the client instance.
			(recv (enc c n1 (pubk as)))
			(send (enc as n1 n2 (pubk c))) 
			(recv (enc n2 (pubk as)))
			(recv (enc c access (hash n1 n2)))
			(send (enc management_uri (enc (cat access_token value access_type) (privk as)) (hash n1 n2)))
			(recv (enc (enc (cat access_token value access_type) (privk as)) (hash n1 n2)))
			(send (enc management_uri_new (enc (cat access_token_new value access_type) (privk as)) (hash n1 n2)))
			
		)
	)
	(defrole resource_server
		(vars (c as rs name) (access_token access_token_new value access_type response response_error response_new data) (n3 n4 text))
		(trace
			(recv (enc c n3 (pubk rs)))
			(send (enc rs n3 n4 (pubk c)))
			(recv (enc n4 (pubk rs)))
			(recv (enc (enc (cat access_token value access_type) (privk as)) (hash n3 n4)))
			(send (enc response (hash n3 n4)))
			(recv (enc (enc (cat access_token value access_type) (privk as)) (hash n3 n4)))
			(send (enc response_error (hash n3 n4)))
			(recv (enc (enc (cat access_token_new value access_type) (privk as)) (hash n3 n4)))
			(send (enc response_new (hash n3 n4)))
		)
	)
)

(defskeleton token_refresh 
  (vars (c as rs name) (n1 n3 text))
  (defstrand client 16 (c c) (as as) (rs rs) (n1 n1) (n3 n3))
  (uniq-orig n1 n3)
  (non-orig (privk c) (privk as) (privk rs))
  (neq (c as) (c rs) (as rs)) 
)

(defskeleton token_refresh 
  (vars (c as name) (n2 text))
  (defstrand authorization_server 7 (c c) (as as) (n2 n2))
  (uniq-orig n2)
  (non-orig (privk c) (privk as))
  (neq (c as)) 
)

(defskeleton token_refresh 
  (vars (c as rs name) (n4 text))
  (defstrand resource_server 9 (c c) (as as) (rs rs) (n4 n4))
  (uniq-orig n4)
  (non-orig (privk c) (privk as) (privk rs))
  (neq (c as) (c rs) (as rs)) 
)
